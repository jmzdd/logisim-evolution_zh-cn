#
# bus/SocBusAttributes.java
#
SocBusTraceSize = 痕迹尺寸: Trace size:
SocBusTraceVisible = 痕迹可见: Traces visible:
#
# bus/SocBusMenuProvider.java
#
insertTrans = 插入一个总线交易 Insert a bus transaction
SocBusMemMap = 显示内存图 Show memory map
SocBusTraceWindow = 显示总线交易跟踪 Show bus transaction(s) trace
SocInsertTransWindowTitle = 向总线插入一个交易: Insert a transaction to bus:
TraceWindowTitleDoubleClickOnTraceToRemoveTrace = 总线跟踪窗口(双击一个跟踪来删除它) Bus trace window (double click on a trace to remove it)
#
# data/SocBusInfo.java
#
SocBusNotConnected = 未连接到总线上 Not connected to a bus
#
# data/SocBusStateInfo.java
#
SocBusNoTrace = 不存在痕迹 No traces present
SocMemMapWindowTitle = 总线的内存图: Memory Map for bus:
SocMemoryMapOk = 关闭 Close
SocMemoryMapTitle = 内存地图(红色表示重叠的内存区域): Memory Map (red indicates overlapping memory regions):
#
# data/SocBusTransaction.java
#
SocBusStateMaster = 发起人: Initiator:
SocBusStateNoDataMax10chars = 无数据
SocBusStateSlave = 响应者: Responder:
SocBusStateTraceIndex = 交易编号。: Transaction nr.:
SocTransactionByteAccesNoSupport = 从机不支持字节存取。 Slave does not support byte accesses.
SocTransactionByteAccesNoSupportShort = 无字节存取 No byte access
SocTransactionHalfWordAccesNoSupport = 从机不支持半字存取。 Slave does not support half word accesses.
SocTransactionHalfWordAccesNoSupportShort = 没有HW通道 No HW access
SocTransactionMisalignedAddress = 从机检测到一个错误的地址。 Slave detected a misaligned address.
SocTransactionMisalignedAddressShort = 不重合的地址。 Misal. Addr.
SocTransactionMultipleSlaveAnswers = 多个从属系统对一个事务作出回应。请检查你的从机的内存图。 Multiple slaves answered to a transaction. Please check the memory map of your slaves.
SocTransactionMultipleSlaveAnswersShort = 多个从属设备 Multiple slaves
SocTransactionNoBusConnected = 主控部件没有连接到任何Soc总线。请将主站连接到一个总线组件。 The master component is not connected to any Soc Bus. Please connect the master to a bus component.
SocTransactionNoBusConnectedShort = 没有总线 No bus
SocTransactionNoneAtomicRW = 要求一个无原子的读/写动作。这是不允许的。 A none atomic read/write action is requested. This is not allowed.
SocTransactionNoneAtomicRWShort = 无原子的RW None atomic RW
SocTransactionNoRespons = 没有从属组件对请求作出回应。请检查请求的内存地址和你系统的内存地图。 No slave component answered to the request. Please check the memory address of the request and the memory map of your system.
SocTransactionNoResponsShort = 没有回应 No response
SocTransactionNoSlavesAttached = 连接到主站的总线没有连接从站。请在总线上安装一些从属设备。 The bus that is connected to the master has no slaves attached. Please attach some slaves to the bus.
SocTransactionNoSlavesAttachedShort = 没有从属 No slaves
SocTransactionReadOnlyAccessError = 从机只支持对该地址的读取访问 Slave supports only read accesses on this address
SocTransactionReadOnlyAccessErrorShort = 只读 Read only
SocTransactionRegisterDoesNotExist = 从机不支持对这个地址的任何访问 Slave does not support any access on this address
SocTransactionRegisterDoesNotExistShort = 无法访问 No access
SocTransactionSuccessfull = 没有发生错误, 交易成功。 No error has occurred, the transaction is successful.
SocTransactionSuccessfullShort = 成功 Success
SocTransactionUnknownError = 很奇怪, 这个错误信息不应该出现, 它代表了逻辑中的一个错误。 Bizarre, this error message should never occur and represents a bug in logisim.
SocTransactionUnknownErrorShort = 是错误！ BUG!
SocTransactionWordAccesNoSupport = 从机不支持字访问。 Slave does not support word accesses.
SocTransactionWordAccesNoSupportShort = 无字访问 No word access
SocTransactionWriteOnlyAccessError = 从机不支持对该地址的读取动作。 Slave does not support a read action on this address.
SocTransactionWriteOnlyAccessErrorShort = 只写 Write only
#
# data/SocMemMapModel.java
#
SocMemMapEmpty = 空的(没有从属) Empty (no slaves)
SocMemMapEndAddress = 最终地址: End address:
SocMemMapSlaveName = 组件名称: Name of component:
SocMemMapStartAddress = 起始地址: Start address:
#
# data/SocSimulationManager.java
#
SocBusManagerSelectBus = 请选择一个要连接的总线 Please select a bus to connect to
SocBusSelectAttr = 连接的总线 Connected bus
SocBusSelectAttrClick = 点击以选择 Click to select
SocManagerNoBusses = 没有可用的总线, 请在您的原理图中添加一个SOC总线 No buses available, please add a SOC-bus to your schematic
#
# data/SocUpMenuProvider.java
#
ProcReadElfLoadedAndEntrySet = 成功地将elf文件载入内存。\n可执行文件的入口点已被设置为处理器。\n\n重要的是。\n 由于elf文件中没有关于异常向量的信息\n   你必须自己控制他们! Successfully loaded the elf file into memory.\nThe entry point of the executable has been set to the processor.\n\nImportant:\n   As the elf file has no information on the exception vectors\n   you have to control them yourself!
SocUpMenuAsmWindow = 开放式汇编程序 Open assembler
SocUpMenuCpuAsmWindowTitle = Cpu的汇编程序: assembler for cpu :
SocUpMenuCpuProgramWindowTitle = 用于Cpu的反汇编程序: disassembler for cpu :
SocUpMenuCpuStateWindowTitle = 中央处理器状态: processor state for cpu :
SocUpMenuErrorReadingElfTitle = 读取elf文件时出错 Error in reading elf file
SocUpMenuReadElf = 读取elf文件 Read elf file
SocUpMenuSelectElfFile = 选择要导入的elf文件 Select elf file to import
SocUpMenuShowProgram = 显示加载的程序 Show loaded program
SocUpMenuShowState = 显示CPU状态 Show CPU state
#
# data/SocUpSimulationState.java
#
SocUpSimHalt = 暂停 Halted
SocUpSimHaltBreak = 断点 Break point
SocUpSimHaltError = 错误 Error
SocUpSimRunning = 运行 Running
SocUpSimStateLabel = 仿真状态: Sim state:
SocUpSimstateStart = 开始 Start
SocUpSimstateStop = 暂停 Pause
SocUpUnknown = 未知 Unknown
#
# file/ElfHeader.java
#
ElfHeaderEIClassError = 不是一个32或64位的elf文件 Not a 32 or 64 bit elf file
ElfHeaderEIDataError = 不是一个小编码或大编码文件 Not a little or big endian encoded file
ElfHeaderIncorrectEISize = EI部分的尺寸是不正确的 The size for the EI-section is incorrect
ElfHeaderIncorrectESize = E部分的尺寸不正确 The size for the E-section is incorrect
ElfHeaderIncorrectMagic = 该文件不包含正确的精灵魔法:可能不是一个elf文件 The file does not contain the correct elf-magic; probably not an elf-file
ElfHeaderNoErrors = 标题是正确的 Header is correct
ElfHeaderReadingFileError = 读取文件时出错 Error reading the file
ElfHeaderUnknownArchitecture = 未知的构架 Unknown architecture
#
# file/ElfProgramHeader.java
#
ProgHeaderNotFound = 没有找到程序头。 Program header not found.
ProgHeaderReadError = 读取程序头时出错。 Error reading program header.
ProgHeaderSizeError = 程序头的尺寸不匹配。 Size mismatch in program header.
ProgHeaderSuccess = 成功 Success
#
# file/ElfSectionHeader.java
#
ElfSectHeadMultiStringtabError = 发现多个字符串表, 暂时不支持。 Found multiple string tables, not supported for the moment.
ElfSectHeadMultiSymtabError = 发现多个符号表, 暂时不支持； Found multiple symbol tables, not supported for the moment;
ElfSectHeadNotFound = 没有找到章节标题。 Section header not found.
ElfSectHeadReadError = 读取章节标题错误。 Error reading section header.
ElfSectHeadSizeError = 节头的尺寸不匹配。 Size mismatch in section header.
ElfSectHeadStingIdxError = 错误字符串索引。 Error String index.
ElfSectHeadStingNotFound = 没有找到章节名称。 Section name not found.
ElfSectHeadStingReadError = 读取字符串表出错。 Error reading string table.
ElfSectHeadStingTypeError = 字符串类型错误。 String type error.
ElfSectHeadSuccess = 成功 Success
ElfSymTableNotFound = 找不到符号表。 Could not find the symbol table.
ElfSymTableReadError = 无法读取符号表。 Could not read the symbol table.
#
# file/ProcessorReadElf.java
#
ProcReadElf64BitNotSupportedYet = Logisim还不支持64位的elf文件。 Logisim does not yet support 64-bit elf files.
ProcReadElfArchError = Elf文件是为一个\"%s\"处理器准备的, 而它应该是为一个\"%s\"处理器准备。 Elf file is for a \"%s\" processor whilst it should be for a \"%s\" processor.
ProcReadElfEndianMismatch =  内码不匹配, elf文件是\"%s\"，而处理器要求是\"%s\"。Endian mismatch, elf file is \"%s\" whilst the processor requested \"%s\".
ProcReadElfErrorOpeningFile = 不可能打开elf文件 Impossible to open elf-file
ProcReadElfLoadableSectionNotFound = 在elf文件中没有找到可加载的部分。 Loadable section not found in elf file.
ProcReadElfLoadableSectionReadError = 读取可加载部分时出错。 Error reading loadable section.
ProcReadElfLoadableSectionSizeError = 可加载部分的尺寸不匹配。 Size mismatch in loadable section.
ProcReadElfLoadableSectionTooBig = 可加载部分的大小与logisim支持的大小一样大。 The size of the loadable section is bigger as the size supported by logisim.
ProcReadElfMemoryError =  发生了一个将可加载部分写入内存的错误。\n确保你有一个SOC内存组件可用于内存区域: \n%s...%s An error occurred writing a loadable section to memory.\nMake sure you have a SOC memory component available for the memory region:\n%s...%s
ProcReadElfNotExecutable = elf-文件不是可执行文件 The elf-file is not an executable
ProcReadElfSuccess = 成功 Success
# 
# gui/AssemblerPanel.java
#
AsmPanAmsFileExtention = 汇编文件（.asm,.S） Assembly files (.asm,.S)
AsmPanAssemble = 组建代码（ALT-A） Assemble the code (ALT-A)
AsmPanDocumentChangedSave = 你的文件有改动，保存它们吗？ There are changes in your document, save them?
AsmPanErrorCreateFile = 无法创建汇编文件。 Unable to create the assembly file.
AsmPanErrorReadingFile = 无法读取文件 Unable to read the file
AsmPanNextError = 跳到下一个错误（CTRL-N） Jump to next error (CTRL-N)
AsmPanOpenFile = 读取一个文件（CTRL-L） Read a file (CTRL-L)
AsmPanPreviousError = 跳转到上一个错误(CTRL-P) Jump to previous error (CTRL-P)
AsmPanReadAsmFile = 选择一个要读取的文件 Select a file to read
AsmPanRun = 运行代码（ALT-R） Run the code (ALT-R)
AsmPanSaveAsmFile = 选择一个要保存的文件 Select a file to save
AsmPanSaveFile = 保存文件（CTRL-S） Save file (CTRL-S)
AsmPanSaveFileAs = 将文件保存为 Save file as
AsmPanSaveFirstBeforeOpen = 你的文件有变化\n你想在打开一个新文件之前保存它们吗？ There are changes in your document\nDo you want to save them before opening a new file?
AssemblerAssembleSuccess = 成功！\n在你的代码中没有发现错误。 Success!\nNo errors found in your code.
AssemblerRunSuccess = 成功地将程序加载到内存中。\n要运行该程序, 请确认：\na) 你启用了刻度线\nb) 你把cpu设置为运行模式 Successfully loaded the program to memory.\nTo run the program, please make sure that:\na) you enable the ticks\nb) you set the cpu to running mode
AssemblerUnableToDownload = 无法将程序存储到内存, \n请确保你有足够的可用内存\在正确的内存位置。 Unable to store the program to memory,\nplease make sure that you have enough memory available\nat the correct memory locations.
RV32imAsmLineIndicator = 第 %d 行的 %d Line %d of %d
#
# gui/BreakpointPanel.java
#
RV32imRemoveBreakPoint = 删除断点 Remove break point
RV32imSetBreakpoint = 增加断点 Add break point
#
# gui/BusTransactionInsertionGui.java
#
SocTransInsAddress = 总线地址:0x Bus address: 0x
SocTransInsAtomicRequest = 原子交易 Atomic transaction
SocTransInsByteAccess = 字节交易 Byte transaction
SocTransInsHalfWordAccess = 半字交易（2字节） Half word transaction (2 bytes)
SocTransInsInputData = 要写的数据:0x Data to write: 0x
SocTransInsInsertTransaction = 将交易插入总线中 Insert the transaction into the bus
SocTransInsManual = 已插入手册 Manual inserted
SocTransInsReadData = 返回的数据: Data returned:
SocTransInsReadRequest = 总线读取请求 Bus read request
SocTransInsTransResultTitle = 插入交易的结果: Result of the inserted transaction:
SocTransInsWordAccess = 字交易(4字节) Word transaction (4 bytes)
SocTransInsWriteRequest = 总线写入请求 Bus write request
#
# gui/CpuDrawSupport.java
#
Rv32imAsmInstruction = 部件: Assembly:
Rv32imBinInstruction = 操作代码: Opcode:
Rv32imEmptyTrace = 没有可用的执行痕迹 No execution traces available
Rv32imExecutionTrace = 执行跟踪(最后一次执行在上面): Execution trace (last executed on top):
Rv32imRegisterFile = 注册文件: Register file:
#
# gui/SocCPUShape.java
#
RV32ShapeSimControl = 仿真控制 Simulation control
#
# jtaguart/JtagUart.java
#
JtagUartClearKeyb = 清除键盘 Clear keyboard
JtagUartKeybAvailable = 可用的键盘数据 Keyboard data available
JtagUartKeybData = 键盘数据 Keyboard data
JtagUartKeybReadEnable = 键盘读取功能 Keyboard read enable
JtagUartTtyClear = TTY清除 TTY clear
JtagUartTtyData = TTY数据 TTY data
JtagUartTtyWrite = TTY写入数据 TTY write data
SocJtagUartComponent = Jtag Uart组件 Jtag Uart component
#
# jtaguart/JtagUartAttributes.java
#
JtagSize1024 = 1k
JtagSize128 = 128
JtagSize16 = 16
JtagSize16384 = 16k
JtagSize2048 = 2k
JtagSize256 = 256
JtagSize32 = 32
JtagSize32768 = 32k
JtagSize4096 = 4k
JtagSize512 = 512
JtagSize64 = 64
JtagSize8 = 8
JtagSize8192 = 8k
JtagUartReadIrqThreshold = 读取IRQ阈值 Read IRQ threshold
JtagUartWriteIrqThreshold = 写入IRQ阈值 Write IRQ threshold
UartJtagREADFifoSize =  读取FIFO大小: Read FIFO size:
UartJtagWriteFifoSize = 写入FIFO大小: Write FIFO size:
#
# memory/SocMemory.java
#
SocMemBase = 基部: Base:
SocMemoryComponent = 内存模拟器 Memory simulator
SocMemSizeStr = 尺寸: Size:
#
# memory/SocMemoryAttributes.java
#
SocMemSize = 字节地址宽度: Byte address width:
SocMemStartAddress = 起始地址: Start address:
#
# nios2/Nios2.java
#
Nios2A = A
Nios2B = B
Nios2C = C
Nios2Component = Nios2s 模拟器 Nios2s simulator
Nios2Dataa = 数据A Data A
Nios2Datab = 数据B Data B
Nios2Done = 完成 Done
Nios2N = N
Nios2ReadRa = 阅读 Ra Read Ra
Nios2ReadRb = 阅读 Rb Read Rb
Nios2Result = 结果 Result
Nios2Start = 开始 Start
Nios2WriteRc = 写入Rc Write Rc
Rv32imClockInput = 时钟信号输入 Clock input
Rv32imIrqInput = IRQ输入%s IRQ input %s
Rv32imResetInput = 复位输入 Reset input
#
# nios2/Nios2Attributes.java
#
nios2BreakVector = 断裂矢量 Break Vector
rv32ExceptionVector = 异常向量 Exception vector
rv32imIrqWidth =  IRQ线的数量 Number of IRQ lines
rv32ResetVector = 复位矢量 Reset vector
rv32StateVisible = 状态可见: State visible:
#
# nios2/Nios2CustomInstructions.java
#
AssemblerExpectedFourArguments = 预期的四个论据 Expected four arguments
Nios2DonePinError = Done引脚未定义或处于错误状态不能继续。\n请检查已完成的管脚。 Done pin not defined or in error state cannot continue.\n Please check the done pin.
#
# nios2/Nios2DataTransferInstructions.java
#
LoadStoreErrorInReadTransaction = 执行从内存系统加载时出错: Error performing a load from memory system:
LoadStoreErrorInWriteTransaction = 向存储系统执行存储时出错: Error performing a store to the memory system:
#
# nios2/Nios2OtherControlInstructions.java
#
AssemblerExpectedImmediateValue = 预计一个即时值 Expected an immediate value
AssemblerExpectedNoArguments = 预计没有参数 Expected no arguments
AssemblerExpectedOneArgument = 预计有一个参数 Expected one argument
AssemblerExpectedTwoArguments = 预计两个参数Expected two arguments
AssemblerExpectedZeroOrOneArgument = 预期没有或只有一个参数 Expected no or one argument
AssemblerImmediateOutOfRange = 即时数值超出范围 The immediate value is out of range
AssemblerUnknownRegister = 未知登记 Unknown register
Nios2AssemblerExpectedBracketedRegister = 预计一个带括号的寄存器, 例如(r1)  Expected a bracketed register, e.g. (r1)
Nios2AssemblerExpectedImmediateIndexedRegister = 期望一个即时索引的寄存器, 例如5(r1) Expected an immediate indexed register, e.g. 5(r1)
Nios2CannotUseControlRegister = 在这种情况下不能使用控制寄存器 Cannot use a control register in this context
Nios2CannotUseCustomRegister = 在这种情况下不能使用自定义寄存器 Cannot use a custom register in this context
Nios2ExpectedControlRegister = 期待一个控制寄存器(如ctl4) Expected a control register (e.g. ctl4)
#
# nios2/Nios2ProgramControlInstructions.java
#
AssemblerExpectedThreeArguments = 预计的三个参数 Expected three arguments
AssemblerExpextedImmediateOrLabel = 预计一个即时值或标签 Expected an immediate value or a label
#
# nios2/Nios2State.java
#
Nios2Bstatus = 状态 bstatus
Nios2Estatus = 状况 estatus
Nios2Status = 现状 status
RV32imBreakPointReached = 由于在当前指令中设置了断点, 执行被暂停。 Execution is paused due to a break point set at the current instruction.
RV32imFetchExecutionError = 执行提取的指令时出错 Error in executing fetched instruction
RV32imFetchInvalidInstruction = 取出的指令无效 Invalid instruction fetched
RV32imFetchInvInstrAsm = 无效的指令! Invalid instruction!
RV32imFetchTransaction = -> 获取交易错误。 Fetch transaction error.
Rv32imProgramCounter = 电脑: pc:
SocHiddenForFasterSimulation = 隐藏内容以加快模拟速度 Contents hidden for faster simulation
#
# nios2/Nios2Support.java
#
AssemblerExpectedRegister = 预计一个寄存器 Expected a register
#
# pio/PioAttributes.java
#
SicPioIrqType = 中断请求类型: Irq type:
SocPioAnyEdge = 任何边缘 Any edge
SocPioBidir = 双向(三态)端口 Bidirectional (tristate) ports
SocPioCaptureEdge = 采集类型: Capture type:
SocPioDirection = 方向: Direction:
SocPioFallingEdge = 下降沿 Falling edge
SocPioGenIRQ = 中断请求已启用: IRQ enabled:
SocPioInout = 既有输入又有输出端口 Both input and output ports
SocPioInputCaptureBit = 捕获位清: Capture bit-clearing:
SocPioInputOnly = 只有输入端口 Input ports only
SocPioInputsSyncCapture = 同步捕获: Sync. capture:
SocPioIrQEdge = 边沿 Edge
SocPioIrqLevel = 层级 Level
SocPioOutputIndividualBits = 输出位设置/清除: Output bit set/clear:
SocPioOutputOnly = 只有输出端口 Output ports only
SocPioOutputResetValue = 输出的复位值: Output reset value:
SocPioRisingEdge = 上升沿 Rising edge
#
# pio/PioMenu.java
#
ErrorCreatingHeaderAndOrCFile = 无法创建头文件和/或c文件! Could not create header and/or c file!
ExportC = 输出C-模板 Export C-templates
PioMenuBidirFunctionsRemark = /*通过以下功能可以对双向寄存器进行设置或读出\n * a 1 表明遵守。位是一个输出, a 0 表示它是一个输入\n * 注意：只有较低的%s位被使用。\n */ /* With the following functions the bi-directional register can be set or read out\n * a 1 indicates that the respect. bit is an output, a 0 indicates it is an input\n * Note: only the lower %s bits are used.\n */
PioMenuCaptureAll = 清除捕获寄存器中的所有位, 与参数 "值 "的值无关 clear all bits in the capture register independently of the value of the parameter "value"
PioMenuCaptureAny = 至少有一个从0到1或从1到0的变化 at least one change from 0 to 1 or from 1 to 0
PioMenuCaptureBit = 清除捕获寄存器中参数 "值 "中为1的位 clear the bits in the capture register that are 1 in the parameter "value"
PioMenuCaptureFalling = 至少有一个从1到0的变化 at least one change from 1 to 0
PioMenuCaptureRising = 至少有一次从0到1的变化 at least one change from 0 to 1
PioMenuEdgeCaptureRemark =/* 通过以下功能，边缘捕获寄存器可以被清除或读出\n * 如果边缘寄存器被读出，一个位置上的1表示\n *  各自的输入有帽子%s,\n * 否则，各自的输入就没有变化。\n * \n * 写入此寄存器将%s。\n * 注意：只有较低的%s位被使用。\n */ /* With the following functions the edge capture register can be cleared or read out\n * in case the edge register is read out a 1 on a position indicates that the\n * respective input has hat %s,\n * otherwise the respective input has not changed.\n * \n * Writing to this register will %s.\n * Note: only the lower %s bits are used.\n */
PioMenuInputDataFunctionRemark = /* 通过以下功能，PIO的输入值可以是\n * 读出。\n * 该函数返回相应的值\n * 注意：只有较低的%s位是有效的\n */ /* With the following function the input values of the PIO can be\n * read out.\n * This function returns the respective value\n * Note: only the lower %s bits are valid\n */
PioMenuIrqEdge = 捕获寄存器中的相应位 corresponding bit in the capture register
PioMenuIrqLevel = 对应的输入 corresponding input
PioMenuMaskFunctionsRemark = /* 通过以下功能可以设置或读出中断屏蔽寄存器。\n * 如果%s等于1。\n * 在一个特定的位置上的1表示将产生一个中断 \n * 注意：只有较低的%s位被使用。\n */ /* With the following functions the Interrupt mask register can be set or read out.\n * A 1 on a specific location indicates that an interrupt will be generated\n * if the %s is equal to 1.\n * Note: only the lower %s bits are used.\n */
PioMenuOutClearRemark = /* 通过以下功能，参数 "值 "中为1的位将强制执行\n * 对应的输出为0\n * 注意：只有较低的%s位被使用。\n */ /* With the following function the bits that are 1 in the parameter "value" will force\n * the corresponding output to 0\n * Note: only the lower %s bits are used.\n */
PioMenuOutputDataFunctionRemark = /* 通过以下功能，PIO的输出值可以是\n * 设置。\n * 该函数将新的输出值作为参数 "value"。\n * 注意：只有所提供的参数 "值 "的低%s位是有效的。\n */ /* With the following function the output values of the PIO can be\n * set.\n * This function takes the new output value as parameter "value"\n * Note: only the lower %s bits of the provided parameter "value" are valid\n */
PioMenuOutSetRemark = /* 通过以下功能，参数 "值 "中为1的位将强制执行\n * 对应的输出为1\n * 注意：只有较低的%s位被使用。\n */ /* With the following function the bits that are 1 in the parameter "value" will force\n * the corresponding output to 1\n * Note: only the lower %s bits are used.\n */
SelectDirectoryToStoreC = 设置存储C-模板的目录 Set directory to store the C-templates
SuccesCreatingHeaderAndCFile = 成功地创建了这些文件: \n %s \n和\n &s Successfully created the files:\n%s\nand\n%s
#
# pio/SocPio.java
#
SocPioBidirPinx = 发送位 %s Bidir bit %s
SocPioBidirs = 双向引脚 Bi-directional pins
SocPioComponent = 并行输入/输出扩展器 Parallel input/output expander
SocPioInputPinx = 输入位%s Input bit %s
SocPioInputs = 输入引脚 Input pins
SocPioIrqOutput = Irq 输出 Irq output
SocPioOutputPinx = 输出位%s Output bit %s
SocPioOutputs = 输出引脚 Output pins
SocPioResetInput = 复位输入 Reset input
#
# rv32im/Rv32im_riscv.java
#
Rv32imComponent = Risc V IM 模拟器 Risc V IM simulator
#
# rv32im/RV32imControlTransferInstructions.java
#
Rv32imAssemblerExpectedOneOrTwoArguments = 预期的一个或两个参数 Expected one or two arguments
Rv32imAssemblerExpectedTwoOrThreeArguments = 预计有两个或三个参数 Expected two or three arguments
#
# rv32im/RV32imEnvironmentCallAndBreakpoints.java
#
Rv32imECABNotImplmented = 目前，环境调用和断点没有实现 Currently the environmental call and breakpoints are not implemented
#
# rv32im/RV32imIntegerRegisterImmediateInstructions.java
#
RV32imAssemblerBUG = 是错误！ BUG!
#
# rv32im/RV32imLoadAndStoreInstructions.java
#
RV32imAssemblerExpectedBracketedRegister = 期待一个带括号的寄存器, 例如(x1) Expected a bracketed register, e.g. (x1)
RV32imAssemblerExpectedImmediateIndexedRegister = 期待一个即时索引的寄存器, 例如:5(x1) Expected an immediate indexed register, e.g. 5(x1)
#
# rv32im/Rv32imMemoryOrderingInstructions.java
#
RV32imAssemblerNotSupportedYet = 不支持的asm操作码 Unsupported asm opcode
Rv32imMOINotImplmented = 目前, 内存排序指令没有实现 Currently the memory ordering instructions are not implemented
#
# Soc.java
#
SocBusComponent = SOC总线仿真器 SOC bus simulator
socLibrary = 片上系统(SoC)器件
#
# util/AbstractAssembler.java
#
AssemblerUnknownOpcode = 未知的操作代码 Unknown opcode
UnknownInstruction = 未知的指令 Unknown instruction
#
# util/Assembler.java
#
AssemblerAssumingEntryPoint = 假设以指令的最低地址作为入口点。\n为了确保你的cpu在正确的地址开始执行\n请添加一个名为"_start "的标签，其位置为\n你的cpu应该在哪里开始执行程序。 Assuming the lowest address with an instruction as entry-point.\nTo make sure that your cpu starts executing at the right address\nplease add a label called '_start' at the location\nwhere your cpu should start executing the program.
AssemblerCannotUseInsideMacro = 该结构不能在宏定义中使用 This construct cannot be used inside a macro definition
AssemblerEndOfMacroNotFound = 找不到宏定义的结尾 Could not find the end of the macro definition
AssemblerExpectedMacroName = 预设得到一个宏的名称 Expected a name of the macro
AssemblerExpectedMacroNrOfParameters = 预计宏观参数的数量 Expected the number of macro parameters
AssemblerExpectingLabelIdentifier = 预设一个标签 Expecting a label
AssemblerMissingLabelBefore = 对于这个操作应该有一个标签 For this operator should be a label
AssemblerNoExecutableSection = 没有发现可以执行的指令。 No instructions found that can be executed.
AssemblerReguiresNumberAfterMath = 在一个数学运算之后, 应该跟着一个数字 After a math operation should follow a number
AssemblerUnknowCharacter = 未知的字符 Unknown character
AssemblerWrongClosingBracket = 不支持该封闭式括号 This closing bracket is not supported
AssemblerWrongOpeningBracket = 不支持这种开口支架 This opening bracket is not supported
#
# util/AssemblerAsmInstruction.java
#
AssemblerCouldNotFindAddressForLabel = 无法确定此标签的地址 Could not determine an address for this label
AssemblerCouldNotFindValueForDefine = 无法找到该参数的定义 Could not find a definition of this parameter
AssemblerDivZero = 除以零的错误 Divide by zero error
AssemblerExpectedImmediateValueAfterMath = 预期在数学运算后立即得到一个值 Expected an immediate value after a math operation
#
# util/AssemblerInfo.java
#
AssemblerDuplicatedLabelNotSupported = 标签名称必须是唯一的, 发现这个标签的多个定义 Label names must be unique, found multiple definitions of this label
AssemblerDuplicatedName = 不能对.equ和标签使用相同的名称 Cannot use the same name for a .equ and a label
AssemblerDuplicatedSectionError = 章节名称必须是唯一的，发现多个章节有此名称 Section names must be unique, found multiple sections with this name
AssemblerExpectedLabel = 预设一个标签 Expected a label
AssemblerExpectedLabelAndNumber = 期望一个标签后有一个即时值 Expected a label followed by an immediate value
AssemblerExpectedParameter = 预期在这个位置有一个参数 Expected a parameter at this position
AssemblerExpectingNumber = 预期的一个数字 Expected a number
AssemblerExpectingPositiveNumber = 预计是一个正数 Expected a positive number
AssemblerExpectingSectionName = 预计本节的名称 Expecting a name for this section
AssemblerExpectingString = 预计是一个字符串 Expected a string
AssemblerMacroIncorrectNumberOfParameters = 指定的宏参数数量不正确 Incorrect number of macro parameters specified
AssemblerOverlappingSections = 本节与另一节重合 This section overlaps with another section
AssemblerUnknownIdentifier = 我不知道这个标识符 I do not know this identifier
AssemblerUnknownLabel = 他的标签还没有被定义, 因此我不能使用它。 This label has not been defined, hence I cannot use it
AssemblerUnsupportedAssemblerInstruction = 这条汇编指令不为人知 This assembler instruction is not known
AssemblerValueOutOfRange = 数值超出了范围 Value is out of range
#
# util/AssemblerMacro.java
#
AssemblerMacroCallingEachotherDeadlock = 宏程序相互调用, 造成死锁情况 Macros are calling each other causing a deadlock situation
AssemblerMacroCannotUseRecurency = 宏程序正在调用自己, 造成了僵局的局面 Macro is calling itself causing a deadlock situation
AssemblerMacroParameterNotDefined = 这个宏参数没有被定义, 请检查你的宏定义中的参数数量 This macro parameter is not defined, check the number of parameters in your macro definition
#
# vga/SocVgaShape.java
#
SocVgaComponent = VGA screen
#
# vga/VgaAttributes.java
#
VgaBufferAddress = 像素缓冲区地址: Pixel buffer Address:
VgaInitialDisplayMode = 初始模式: Initial mode:
VgaMode1024x768 = 1024x768
VgaMode160x120 = 160x120
VgaMode320x240 = 320x240
VgaMode640x480 = 640x480
VgaMode800x600 = 800x600
VgaSoft1024x768 = 软件 1024x768: Software 1024x768:
VgaSoft160x120 = 软件 160x120: Software 160x120:
VgaSoft320x240 = 软件 320x240: Software 320x240:
VgaSoft640x480 = 软件 640x480: Software 640x480:
VgaSoft800x600 = 软件 800x600: Software 800x600:
VgaStartAddress = 基本地址: Base address:
#
# vga/VgaMenu.java
#
VgaMenuModeSelectFunctions = /* 通过以下功能，可以对VGA模式进行操作。\n * 读取vga模式会返回支持的模式（见上文对可能模式的定义）。\n * 写入一个支持的模式将改变VGA显示器的显示模式\n */ /* With the following functions the vga mode can be manipulated.\n * Reading the vga mode returns the supported modes (see above defines of possible modes)\n * Writing a supported mode will change the display mode of the VGA display\n */


